#!/usr/bin/perl

# fasta2nexus.pl v0.1.0
# Author: MH Seabolt
# Last updated: 8-13-2021

# SYNOPSIS:
# Converts a FASTA alignment file to Nexus format for PAUP, MrBayes, Mesquite, etc

##################################################################################
# The MIT License
#
# Copyright (c) 2021 Matthew H. Seabolt
#
# Permission is hereby granted, free of charge, 
# to any person obtaining a copy of this software and 
# associated documentation files (the "Software"), to 
# deal in the Software without restriction, including 
# without limitation the rights to use, copy, modify, 
# merge, publish, distribute, sublicense, and/or sell 
# copies of the Software, and to permit persons to whom 
# the Software is furnished to do so, 
# subject to the following conditions:
#
# The above copyright notice and this permission notice 
# shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
##################################################################################

use strict;
use warnings;
no warnings 'uninitialized';
use Getopt::Long qw(GetOptions);

# Required input parameters
my $fasta = "--";
my $output = "--";
my $gap = "-";
my $missing = "?";
my $type;
my $newick;
my $phylip;
my $fix_headers;
my $partitions;
my $revcom;
my $substring;
my $fetch;

sub usage {
	my $usage = "fasta2nexus.pl\n
	PURPOSE: 	Converts a FASTA file to NEXUS format for use with PAUP, Mesquite, MrBayes, etc.\n
	USAGE:	fasta2nexus.pl -i input.fasta -o output.nex -t dna -g - -m ?
	-i		input alignment file in FASTA format
	-m		character used for missing data in the alignment (default: '?')
	-g		gap character used in the alignment (assumed to be '-')
	-t		data type (either DNA, protein, binary )
	-n 		tree file in Newick format to include (optional)
	-c		INT flag, correct headers? (Default OFF)
	-o		output file name with .nex extension
	-p		Optionally output Phylip format as well (INT flag, Default OFF) 
	-s		partitions file, generated by concat_alignments.pl
	-f 		STR; string pattern to match for fetching subset of sequences
	-revcom		Reverse complement
	-substr		STR; print out only a substring of the original sequences, given as startPosition:endPosition (eg. 1:1000 returns the first 1000 bp)
	\n";
	print $usage;
}

GetOptions(	'input|i=s' => \$fasta,
			'out|o=s' => \$output,
			'missing|m=s' => \$missing,
			'gap|g=s' => \$gap,
			'newick|n=s' => \$newick,
			'correct|c=i' => \$fix_headers,
			'type|t=s' => \$type,
			'phylip|p=i' => \$phylip,
			'partitions|s=s' => \$partitions,
			'revcom' => \$revcom,
			'substr=s' => \$substring,
			'fetch|f=s' => \$fetch,
) or die usage();

# Parameter setups
$gap = ( $gap ne "-")? $gap : "-";
$missing = ( $missing ne "?")? $missing : "?";
if ( $type =~ /bin/ )	{
	$type = "BIN";
}
elsif ( $type =~ /pro/ || $type =~ /aa/ )	{
		$type = "protein";
}
else	{
	$type = "DNA";
}
$phylip = ( defined($phylip) || $phylip == 1)? 1 : 0;
$fix_headers = ( $fix_headers eq "1")? 1 : 0;

my $start;
my $end;
if ( $substring )	{
	my @sub = split(":", $substring);
	
	if ( $sub[1] < $sub[0] )	{
		$start = $sub[1] - 1 ;						# -1 is included to account for Perl's 0-indexing
		$end = abs($sub[0] - $start);
		$revcom = 1;
	}
	else	{
		$start = $sub[0] - 1 ;						# -1 is included to account for Perl's 0-indexing
		$end = abs($sub[1] - $start);
	}
}


# Store the FASTA sequences in a hash
$/ = ">";
my @fastas;
if ( $fasta && -e $fasta )	{
	open DATA, $fasta or die "Something is wrong with your input fasta file.  $!\n";
		@fastas = <DATA>;
		my $trash = shift @fastas;	# Get rid of the first element, which will be a lone ">" symbol
	close DATA;
}
else		{		# Assume STDIN
	@fastas = <STDIN>;
	my $trash = shift @fastas;	# Get rid of the first element, which will be a lone ">" symbol
}
$/ = "\n";

my %Alignment = ();
foreach my $record ( @fastas )	{
	my ($header, @seq) = split "\n", $record;
	my $seq = join '', @seq;
	my @headers = split " ", $header;
	
	$headers[0] =~ s/ /_/g;				# Convert any spaces to underscores
	$headers[0] =~ s/-//g;				# Convert any hyphens in SEQUENCE NAMES to underscores (Paup really doesnt like these)
	$headers[0] =~ s/\s+//g;			# Remove any other odd whitespace
	$headers[0] =~ s/\|//g;				# Remove pipe chars (often seen in Genbank headers)
	$seq =~ s/>//g;						# Remove any lingering ">" symbols
	$seq =~ s/\./N/g;						# Remove any lingering ">" symbols
	$seq = uc $seq;						# Convert everything to uppercase 
	
	if ( $type eq "protein" )	{
		$seq =~ s/\*$//g;
	}
	
	$seq = revcom( $seq ) if ( $revcom && $type ne "protein" );
	$seq = substr( $seq, $start, $end ) if ( $substring );
	
	# Store the sequences as a hash
	$Alignment{$headers[0]} = $seq;
}	

# Correct the weird headers if this flag is activated
my %NewHash = ();
if ( $fix_headers == 1 )	{
	my $newhash = fix_headers(\%Alignment);
	%NewHash = %{$newhash};
	%Alignment = %NewHash;
}

if ( $fetch )	{
	foreach my $key ( sort keys %Alignment )	{
		if ( $key !~ /$fetch/ )	{
			delete $Alignment{$key};
		}
	}
}

# Get some basic info from the hash
my $ntax = scalar ( keys %Alignment );
my $nchar = length( get_longest_hash_value(\%Alignment) ); #- 1;
my $longest_name = length( get_longest_hash_key(\%Alignment) );

# Set the output filehandles
my $succout = open( OUT, ">", "$output" ) if $output ne "--";
my $fhout;
if ( $succout )		{	$fhout = *OUT;			}
else				{	$fhout = *STDOUT;		}

# Conversion process
chomp(my $date = `date`); 
my $head = sprintf("#NEXUS\n[written $date by fasta2Nexus.pl]\n\n");
print $fhout "$head";

# Generate the DATA block with the alignment
print $fhout "BEGIN DATA;\n";
print $fhout "DIMENSIONS NTAX=$ntax NCHAR=$nchar;\n";
print $fhout "FORMAT DATATYPE = $type GAP = $gap MISSING = $missing Interleave = no;\n" if ( $type ne "BIN" );
print $fhout "\tMATRIX\n";
print $fhout "\t[Note: terminal stop codons removed for protein data, if detected.]\n" if ( $type eq "protein" );

foreach my $sequence ( sort keys %Alignment )	{
	my $line = "\t";
	$line .= sprintf("$sequence" . (" " x ((10 + $longest_name) - length($sequence))) );
	my $endgaps = sprintf("-" x ($nchar - length($Alignment{$sequence}))) if ( $nchar - length($Alignment{$sequence}) > 0 );
	my $sequence .= $Alignment{$sequence} . $endgaps;
	$sequence =~ s/\s+//g;
	$line .= $sequence;
	print $fhout "$line\n";
}
print $fhout ";\nEND;\n\n";

# Set up a SETS block with information on which partitions are where
# And include a PAUP block for performing an ILD / partition homogeneity test
if ( -e $partitions )	{
	open PARTS, $partitions or warn;
		my @partitions = <PARTS>;
	close PARTS;
	
	my @all_part;
	my $codon_pos1;
	my $codon_pos2;
	my $codon_pos3;
	print $fhout "BEGIN SETS;\n";
	foreach my $line ( @partitions )	{
		chomp $line;
		my @data = split "\t", $line;
		
		push @all_part, "$data[1]:$data[2]-$data[3]";		# Append each new charset to the description of the ALL set
		
		# Write the SETS block from this data
		print $fhout "\tcharset $data[1]=$data[2]-$data[3];\n";
		
		# Include the codon position charsets, ASSUMING that the data are codons in Reading Frame 1 (make manual adjustments here as needed)
		$codon_pos1 .= " $data[2]-$data[3]\\3";
			$data[2] += 1;
		$codon_pos2 .= " $data[2]-$data[3]\\3";
			$data[2] += 1;
		$codon_pos3 .= " $data[2]-$data[3]\\3";
		
	}
	
	# Print out the total partition, plus the coding partition charsets.  Again, make manual adjustments if needed.
	print $fhout "\tcharset 1stpos =" . "$codon_pos1" .";\n";
	print $fhout "\tcharset 2ndpos =" . "$codon_pos2" .";\n";
	print $fhout "\tcharset 3rdpos =" . "$codon_pos3" .";\n";
	print $fhout "\tcharpartition all = ", join(",", @all_part), ";\n";
	print $fhout "END;\n\n";
} 



# Include the tree block if a Newick file is given as a tree
if ( -e $newick )	{
	
	open NWK, $newick or warn;
		my @newick_file = <NWK>;
		my $tree = $newick_file[0];	# The tree will only be on the first line, should also incl the ';' at the end 
	close NWK;
	
	# Write the tree block
	my $i = 1;
	print $fhout "BEGIN TREES;\n";
	print $fhout "\ttree tree$i = $tree";
	print $fhout "END;\n\n";	
}

close $fhout if ( $succout );

if ( $phylip == 1 ) 	{
	$output =~ s/\.nex//g;
	open PHYLIP, ">", "$output.phylip" or die;
	print PHYLIP "$ntax $nchar\n";
	
	foreach my $sequence ( keys %Alignment )	{
		my $line = sprintf("$sequence" . (" " x ((10 + $longest_name) - length($sequence))) );
		my $endgaps = sprintf("-" x ($nchar - length($Alignment{$sequence}))) if ( $nchar - length($Alignment{$sequence}) > 0 );
		my $sequence .= $Alignment{$sequence} . $endgaps;
		$sequence =~ s/\s+//g;
		$line .= $sequence;
		print PHYLIP "$line\n";
	}
	close PHYLIP;
}


exit;

########################## SUBROUTINES  ##################################

# Get the longest VALUE in a hash
# Accepts a hash reference as input, returns a scalar VALUE (not its length!)
sub get_longest_hash_value	{
	my ( $hash ) = @_;
	my %Hash = %{$hash};
	my $longest = (sort values %Hash)[0];
	
	foreach my $value ( sort values %Hash )	{
		if ( length($longest) > length($value) )	{
			$longest = $longest;
		}
		else		{
			$longest = $value;
		}
	}
	return($longest);	# - 1
}

# Get the longest VALUE in a hash
# Accepts a hash reference as input, returns a scalar KEY (not its length!)
sub get_longest_hash_key	{
	my ( $hash ) = @_;
	my %Hash = %{$hash};
	my $longest = (sort keys %Hash)[0];
	
	foreach my $value ( keys %Hash )	{
		$longest = length($longest) > length($value)? $longest : $value;
	}
	
	return $longest;
}

# Corrects lengthy fasta headers that are often generated by automatic programs -- ie. find_core_genome.pl // core_genome_reads.pl
# Returns a hash reference with corrected headers
sub fix_headers	{
	my $hash = shift;
	my %Hash = %{$hash};
	
	my %NewHash = ();
	foreach my $header ( sort keys %Hash )	{
		my $seq = $Hash{$header};
		my $new_header = $header;
		$new_header =~ s/\.fasta.*$//g;		
		$NewHash{$new_header} = $seq;
	}
	
	return \%NewHash;

}

# Reverse complements a sequence
sub revcom	{
	my ( $seq ) = @_;
	my $revcom = $seq;
	
	$revcom =~ tr/ACGTacgt/TGCAtgca/;
	print "$revcom\n";
	$revcom = reverse $revcom;
	
	return ( uc $revcom );
}

